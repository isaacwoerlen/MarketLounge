from typing import Dict, List
from celery import shared_task
from django.apps import apps
from django.db import transaction
from django.conf import settings
import logging

from apps.language.utils import get_active_langs, get_default_lang, validate_seo_lengths
from apps.language.ai import translate_bulk
from apps.language.models import TranslatableKey, Translation, TranslationJob

logger = logging.getLogger("apps.language")

@shared_task
def translate_glossary_nodes(
    glossary_ids: List[str],
    source_lang: str | None = None,
    target_langs: List[str] | None = None,
    only_missing: bool = True,
    include_seo: bool = True,
) -> Dict:
    """
    Complète les champs multilingues via IA (Mistral) ou traductions existantes.
    - source_lang: langue de saisie (défaut = langue par défaut).
    - target_langs: langues à remplir (si None => langues actives).
    - only_missing: si True, n'écrase pas les champs déjà renseignés.
    - include_seo: inclut seo.description / seo.keywords (valide longueurs).
    """
    Node = apps.get_model("glossary", "GlossaryNode")
    langs = target_langs or get_active_langs()
    default_lang = source_lang or get_default_lang()
    processed = errors = 0

    # Valider langues cibles
    invalid_langs = [lang for lang in langs if lang not in get_active_langs()]
    if invalid_langs:
        logger.error(f"Langues cibles invalides : {invalid_langs}")
        return {"processed": 0, "errors": len(glossary_ids), "invalid_langs": invalid_langs}

    # Créer TranslationJob
    job = TranslationJob.objects.create(
        job_type="bulk" if not include_seo else "seo_only",
        provider="mistral",
        target_locales=langs,
        scope_filter={"scope": "glossary" if not include_seo else "seo"},
        state="running",
    )

    for gid in glossary_ids or []:
        try:
            node = Node.objects.get(glossary_id=gid)
        except Node.DoesNotExist:
            logger.error(f"GlossaryNode {gid} introuvable")
            errors += 1
            job.errors.append({"glossary_id": gid, "error": "Node introuvable"})
            job.save()
            continue

        # 1) Collecter source
        def _get(d: dict, lang: str) -> str:
            if not isinstance(d, dict):
                return ""
            v = d.get(lang)
            return v if isinstance(v, str) else ""

        src = {
            "label": _get(node.labels, default_lang),
            "definition": _get(node.definition, default_lang),
            "procede": _get(node.procede, default_lang),
            "explication_technique": _get(node.explication_technique, default_lang),
        }
        if include_seo:
            seo_src = (node.seo or {}).get(default_lang, {})
            src["seo_description"] = seo_src.get("description") or ""
            src["seo_keywords"] = ", ".join(seo_src.get("keywords", [])) if isinstance(seo_src.get("keywords"), list) else (seo_src.get("keywords") or "")

        if not any(src.values()):
            logger.warning(f"GlossaryNode {gid} sans contenu traduisible en {default_lang}")
            processed += 1
            continue

        # 2) Identifier cibles manquantes
        targets = []
        for lang in langs:
            if lang == default_lang:
                continue
            if only_missing:
                missing = False
                if not (node.labels or {}).get(lang):
                    missing = True
                if not (node.definition or {}).get(lang):
                    missing = True
                if include_seo:
                    sblk = (node.seo or {}).get(lang, {})
                    if not sblk.get("description") or not sblk.get("keywords"):
                        missing = True
                if not missing:
                    continue
            targets.append(lang)

        if not targets:
            processed += 1
            continue

        # 3) Vérifier traductions existantes (optimisation avant Mistral)
        translations = {}
        for lang in targets:
            for field in src.keys():
                key, _ = TranslatableKey.objects.get_or_create(
                    scope="seo" if field.startswith("seo_") else "glossary",
                    key=field.replace("seo_", ""),
                    defaults={"checksum": ""}  # À calculer si besoin
                )
                existing = Translation.objects.filter(
                    key=key, locale__code=lang, status="published"
                ).first()
                if existing:
                    translations.setdefault(lang, {})[field] = existing.value

        # 4) Appeler Mistral pour traductions manquantes
        missing_langs = [lang for lang in targets if lang not in translations]
        if missing_langs:
            try:
                tr = translate_bulk(src, source_lang=default_lang, target_langs=missing_langs)
                translations.update(tr)
            except Exception as e:
                logger.error(f"Erreur Mistral pour {gid}: {str(e)}")
                errors += 1
                job.errors.append({"glossary_id": gid, "error": str(e)})
                job.save()
                continue

        # 5) Hydrater node et enregistrer traductions
        with transaction.atomic():
            node.labels = node.labels or {}
            node.definition = node.definition or {}
            node.procede = node.procede or {}
            node.explication_technique = node.explication_technique or {}
            node.seo = node.seo or {}

            for lang, fields in translations.items():
                if not isinstance(fields, dict):
                    continue
                def set_if_missing(mapping, key, field):
                    val = fields.get(field)
                    if val and (not mapping.get(lang) if key in {"label", "definition", "procede", "explication_technique"} else True):
                        if key == "label":
                            node.labels[lang] = val
                        elif key == "definition":
                            node.definition[lang] = val
                        elif key == "procede":
                            node.procede[lang] = val
                        elif key == "explication_technique":
                            node.explication_technique[lang] = val

                set_if_missing(node.labels, "label", "label")
                set_if_missing(node.definition, "definition", "definition")
                set_if_missing(node.procede, "procede", "procede")
                set_if_missing(node.explication_technique, "explication_technique", "explication_technique")

                if include_seo:
                    sblk = node.seo.get(lang, {})
                    if fields.get("seo_description"):
                        sblk["description"] = fields["seo_description"]
                    if fields.get("seo_keywords"):
                        sblk["keywords"] = [w.strip() for w in fields["seo_keywords"].split(",") if w.strip()]
                    node.seo[lang] = sblk

                # Enregistrer dans Translation
                for field, value in fields.items():
                    if not value:
                        continue
                    scope = "seo" if field.startswith("seo_") else "glossary"
                    key, _ = TranslatableKey.objects.get_or_create(
                        scope=scope,
                        key=field.replace("seo_", ""),
                        defaults={"checksum": ""}  # À calculer si besoin
                    )
                    alerts = validate_seo_lengths(value, field) if scope == "seo" else []
                    Translation.objects.update_or_create(
                        key=key,
                        locale_id=lang,
                        version=1,
                        defaults={
                            "value": value,
                            "status": "draft",
                            "alerts": alerts,
                        }
                    )

            node.full_clean()
            node.save()

        processed += 1

    job.state = "completed" if errors == 0 else "failed"
    job.stats = {"processed": processed, "errors": errors}
    job.save()
    return {"processed": processed, "errors": errors}