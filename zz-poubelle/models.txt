# apps\transversales\language\models.py
from django.db import models
from django.core.exceptions import ValidationError
from django.core.validators import RegexValidator
from django.core.cache import cache
from django.utils.translation import gettext_lazy as _
from django.db.models import Q

# --- Cache ---
LANG_CACHE_TTL = 60  # Configurable via settings si besoin

def _ck(suffix: str) -> str:
    """Fabrique de clés de cache (cohérente pour set + invalidation)."""
    return f"language:{suffix}"

# --- Validateur codes langue ---
# ex. 'fr', 'en', 'pt-br' (normalisé en minuscule dans save())
CODE_VALIDATOR = RegexValidator(
    regex=r'^[a-z]{2}(-[a-z]{2})?$',
    message="Code langue invalide (ex: 'fr', 'en', 'pt-br').",
)

# --- Manager ---
class LanguageManager(models.Manager):
    def get_default(self):
        def _compute():
            obj = (self.filter(is_default=True).first()
                   or self.filter(is_active=True).order_by('priority', 'code').first())
            return obj.code if obj else 'en'  # fallback minimal
        return cache.get_or_set(_ck("default"), _compute, timeout=LANG_CACHE_TTL)

    def get_active(self):
        def _compute():
            return list(self.filter(is_active=True)
                        .order_by('priority', 'code')
                        .values_list('code', flat=True))
        return cache.get_or_set(_ck("active"), _compute, timeout=LANG_CACHE_TTL)

# --- Language ---
class Language(models.Model):
    code = models.CharField(max_length=10, unique=True, validators=[CODE_VALIDATOR])
    name = models.CharField(max_length=100)
    is_active = models.BooleanField(default=True)
    is_default = models.BooleanField(default=False)
    priority = models.IntegerField(default=5, db_index=True)  # 1 = haute priorité
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    # ✅ Micro-fix #1 : brancher le manager custom
    objects = LanguageManager()

    class Meta:
        constraints = [
            models.UniqueConstraint(fields=['code'], name='unique_language_code'),
            # is_default=True => doit être active
            models.CheckConstraint(
                check=Q(is_default=False) | Q(is_active=True),
                name='default_lang_must_be_active',
            ),
            # ✅ Unicité de la langue par défaut (une seule True)
            models.UniqueConstraint(
                fields=['is_default'],
                condition=Q(is_default=True),
                name='unique_default_language_true',
            ),
        ]
        indexes = [models.Index(fields=['is_active', 'priority'])]

    def save(self, *args, **kwargs):
        # Normalisation lean
        self.code = self.code.lower().replace('_', '-')
        if self.is_default:
            self.is_active = True
            # Désélectionner les autres défauts
            Language.objects.filter(is_default=True).exclude(pk=self.pk).update(is_default=False)
        super().save(*args, **kwargs)
        # ✅ Micro-fix #2 : invalidation des mêmes clés que celles utilisées par le manager
        cache.delete_many([_ck("default"), _ck("active")])

    def __str__(self):
        return f"{self.name} ({self.code})"

# --- TranslatableKey ---
class TranslatableKey(models.Model):
    scope = models.CharField(max_length=64, db_index=True)
    key = models.CharField(max_length=255, db_index=True)
    checksum = models.CharField(max_length=64, db_index=True, editable=False)
    is_blocking = models.BooleanField(default=False)
    prompt_template = models.JSONField(default=dict, blank=True)   # prêt pour LLM
    tenant_id = models.CharField(max_length=36, null=True, blank=True, db_index=True)  # lean UUID string
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(fields=['scope', 'key'], name='uniq_scope_key'),
        ]
        indexes = [
            models.Index(fields=['scope', 'key']),
            models.Index(fields=['tenant_id']),
        ]

    def __str__(self):
        return f"{self.scope} → {self.key}"

# --- Translation ---
class Translation(models.Model):
    key = models.ForeignKey('TranslatableKey', on_delete=models.CASCADE, related_name='translations')
    language = models.ForeignKey('Language', on_delete=models.PROTECT, db_index=True)
    text = models.TextField()
    version = models.IntegerField(default=1)
    alerts = models.JSONField(default=list, blank=True)
    reviewer = models.CharField(max_length=100, blank=True, null=True)  # Lean, pas de FK
    embedding = models.BinaryField(null=True, blank=True)  # Prévoir faiss_pgvector
    source_checksum = models.CharField(max_length=64, blank=True, default="")  # Checksum source
    origin = models.CharField(max_length=16, choices=[("tm", "Translation Memory"), ("llm", "LLM")], default="llm")
    provider_info = models.JSONField(default=dict, blank=True)  # e.g., {"provider": "mistral", "model": "large-latest"}
    domain = models.CharField(max_length=32, blank=True, null=True, db_index=True)  # e.g., "seo", "ui"
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(fields=['key', 'language', 'version'], name='uniq_key_language_version'),
            models.CheckConstraint(check=Q(version__gte=1), name='translation_version_gte_1'),
        ]
        indexes = [
            models.Index(fields=['language']),
            models.Index(fields=['key', 'language']),
            models.Index(fields=['updated_at']),
            models.Index(fields=['source_checksum']),
            models.Index(fields=['domain']),
        ]
        ordering = ('-updated_at', '-version')

    def clean(self):
        if not isinstance(self.alerts, list) or any(not isinstance(x, dict) for x in self.alerts):
            raise ValidationError(_('Alerts must be a list of dicts.'))
        if not isinstance(self.provider_info, dict):
            raise ValidationError(_('Provider_info must be a dict.'))
        # Validation SEO déléguée à services.py

    def __str__(self):
        return f"[{self.language.code}] {self.key.key}"

# --- TranslationJob ---
class TranslationJob(models.Model):
    name = models.CharField(max_length=255)
    state = models.CharField(
        max_length=16,
        choices=[('queued', 'Queued'), ('running', 'Running'), ('done', 'Done'), ('failed', 'Failed')],
        default='queued',
        db_index=True,
    )
    source_locale = models.CharField(max_length=10, validators=[CODE_VALIDATOR])
    target_locales = models.JSONField(default=list)
    scope_filter = models.JSONField(default=list)  # Aligné avec README_language.md
    stats = models.JSONField(default=dict)
    errors = models.JSONField(default=list)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def clean(self):
        if (not isinstance(self.target_locales, list)
            or not isinstance(self.scope_filter, list)
            or not isinstance(self.stats, dict)
            or not isinstance(self.errors, list)):
            raise ValidationError(_('Invalid JSON field formats.'))

        active = Language.objects.get_active()
        invalid_locales = [loc for loc in self.target_locales if loc not in active]
        if invalid_locales:
            raise ValidationError(f"Invalid locales: {invalid_locales}")
        if self.source_locale not in active:
            raise ValidationError(f"Invalid source locale: {self.source_locale}")

    def __str__(self):
        return f"{self.name} ({', '.join(self.target_locales)})"